<!DOCTYPE HTML>
<!-- NewPage -->
<html lang="en">
<head>
<!-- Generated by javadoc -->
<title>NodeQuery (testfx-core 4.0.17-alpha-SNAPSHOT API)</title>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<link rel="stylesheet" type="text/css" href="../../../../../stylesheet.css" title="Style">
<link rel="stylesheet" type="text/css" href="../../../../../jquery/jquery-ui.css" title="Style">
<script type="text/javascript" src="../../../../../script.js"></script>
<script type="text/javascript" src="../../../../../jquery/jszip/dist/jszip.min.js"></script>
<script type="text/javascript" src="../../../../../jquery/jszip-utils/dist/jszip-utils.min.js"></script>
<!--[if IE]>
<script type="text/javascript" src="../../../../../jquery/jszip-utils/dist/jszip-utils-ie.min.js"></script>
<![endif]-->
<script type="text/javascript" src="../../../../../jquery/jquery-3.3.1.js"></script>
<script type="text/javascript" src="../../../../../jquery/jquery-migrate-3.0.1.js"></script>
<script type="text/javascript" src="../../../../../jquery/jquery-ui.js"></script>
</head>
<body>
<script type="text/javascript"><!--
    try {
        if (location.href.indexOf('is-external=true') == -1) {
            parent.document.title="NodeQuery (testfx-core 4.0.17-alpha-SNAPSHOT API)";
        }
    }
    catch(err) {
    }
//-->
var data = {"i0":6,"i1":6,"i2":6,"i3":6,"i4":6,"i5":6,"i6":6,"i7":6,"i8":6,"i9":6,"i10":6,"i11":6,"i12":6,"i13":18,"i14":18,"i15":18,"i16":18,"i17":18,"i18":18,"i19":18,"i20":18,"i21":18,"i22":6,"i23":6};
var tabs = {65535:["t0","All Methods"],2:["t2","Instance Methods"],4:["t3","Abstract Methods"],16:["t5","Default Methods"]};
var altColor = "altColor";
var rowColor = "rowColor";
var tableTab = "tableTab";
var activeTableTab = "activeTableTab";
var pathtoroot = "../../../../../";
var useModuleDirectories = true;
loadScripts(document, 'script');</script>
<noscript>
<div>JavaScript is disabled on your browser.</div>
</noscript>
<header role="banner">
<nav role="navigation">
<div class="fixedNav">
<!-- ========= START OF TOP NAVBAR ======= -->
<div class="topNav"><a id="navbar.top">
<!--   -->
</a>
<div class="skipNav"><a href="#skip.navbar.top" title="Skip navigation links">Skip navigation links</a></div>
<a id="navbar.top.firstrow">
<!--   -->
</a>
<ul class="navList" title="Navigation">
<li><a href="../../../../module-summary.html">Module</a></li>
<li><a href="package-summary.html">Package</a></li>
<li class="navBarCell1Rev">Class</li>
<li><a href="class-use/NodeQuery.html">Use</a></li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../../../../../deprecated-list.html">Deprecated</a></li>
<li><a href="../../../../../index-files/index-1.html">Index</a></li>
<li><a href="../../../../../help-doc.html">Help</a></li>
</ul>
</div>
<div class="subNav">
<div>
<ul class="subNavList">
<li>Summary:&nbsp;</li>
<li>Nested&nbsp;|&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li>Constr&nbsp;|&nbsp;</li>
<li><a href="#method.summary">Method</a></li>
</ul>
<ul class="subNavList">
<li>Detail:&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li>Constr&nbsp;|&nbsp;</li>
<li><a href="#method.detail">Method</a></li>
</ul>
</div>
<ul class="navListSearch">
<li><label for="search">SEARCH:</label>
<input type="text" id="search" value="search" disabled="disabled">
<input type="reset" id="reset" value="reset" disabled="disabled">
</li>
</ul>
</div>
<a id="skip.navbar.top">
<!--   -->
</a>
<!-- ========= END OF TOP NAVBAR ========= -->
</div>
<div class="navPadding">&nbsp;</div>
<script type="text/javascript"><!--
$('.navPadding').css('padding-top', $('.fixedNav').css("height"));
//-->
</script>
</nav>
</header>
<!-- ======== START OF CLASS DATA ======== -->
<main role="main">
<div class="header">
<div class="subTitle"><span class="moduleLabelInType">Module</span>&nbsp;<a href="../../../../module-summary.html">org.testfx</a></div>
<div class="subTitle"><span class="packageLabelInType">Package</span>&nbsp;<a href="package-summary.html">org.testfx.service.query</a></div>
<h2 title="Interface NodeQuery" class="title">Interface NodeQuery</h2>
</div>
<div class="contentContainer">
<div class="description">
<ul class="blockList">
<li class="blockList">
<dl>
<dt>All Known Implementing Classes:</dt>
<dd><code><a href="impl/NodeQueryImpl.html" title="class in org.testfx.service.query.impl">NodeQueryImpl</a></code></dd>
</dl>
<hr>
<pre>public interface <span class="typeNameLabel">NodeQuery</span></pre>
</li>
</ul>
</div>
<div class="summary">
<ul class="blockList">
<li class="blockList">
<!-- ========== METHOD SUMMARY =========== -->
<section role="region">
<ul class="blockList">
<li class="blockList"><a id="method.summary">
<!--   -->
</a>
<h3>Method Summary</h3>
<div class="memberSummary">
<div role="tablist" aria-orientation="horizontal"><button role="tab" aria-selected="true" aria-controls="memberSummary_tabpanel" tabindex="0" onkeydown="switchTab(event)" id="t0" class="activeTableTab">All Methods</button><button role="tab" aria-selected="false" aria-controls="memberSummary_tabpanel" tabindex="-1" onkeydown="switchTab(event)" id="t2" class="tableTab" onclick="show(2);">Instance Methods</button><button role="tab" aria-selected="false" aria-controls="memberSummary_tabpanel" tabindex="-1" onkeydown="switchTab(event)" id="t3" class="tableTab" onclick="show(4);">Abstract Methods</button><button role="tab" aria-selected="false" aria-controls="memberSummary_tabpanel" tabindex="-1" onkeydown="switchTab(event)" id="t5" class="tableTab" onclick="show(16);">Default Methods</button></div>
<div id="memberSummary_tabpanel" role="tabpanel">
<table aria-labelledby="t0">
<tr>
<th class="colFirst" scope="col">Modifier and Type</th>
<th class="colSecond" scope="col">Method</th>
<th class="colLast" scope="col">Description</th>
</tr>
<tbody>
<tr class="altColor" id="i0">
<td class="colFirst"><code><a href="NodeQuery.html" title="interface in org.testfx.service.query">NodeQuery</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#from(java.util.Collection)">from</a></span>&#8203;(<a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/Collection.html?is-external=true" title="class or interface in java.util" class="externalLink">Collection</a>&lt;javafx.scene.Node&gt;&nbsp;parentNodes)</code></th>
<td class="colLast">
<div class="block">Stores all given <code>parentNodes</code> within this NodeQuery.</div>
</td>
</tr>
<tr class="rowColor" id="i1">
<td class="colFirst"><code><a href="NodeQuery.html" title="interface in org.testfx.service.query">NodeQuery</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#from(javafx.scene.Node...)">from</a></span>&#8203;(javafx.scene.Node...&nbsp;parentNodes)</code></th>
<td class="colLast">
<div class="block">Stores all given <code>parentNodes</code> within this NodeQuery.</div>
</td>
</tr>
<tr class="altColor" id="i2">
<td class="colFirst"><code><a href="NodeQuery.html" title="interface in org.testfx.service.query">NodeQuery</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#lookup(java.lang.String)">lookup</a></span>&#8203;(<a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/String.html?is-external=true" title="class or interface in java.lang" class="externalLink">String</a>&nbsp;query)</code></th>
<td class="colLast">
<div class="block">Sifts through stored nodes by their id ("#id"), their class (".class"), or the text it has ("text"),
 depending on the query used, and keeps only those <code>Node</code>s that meet the query.</div>
</td>
</tr>
<tr class="rowColor" id="i3">
<td class="colFirst"><code><a href="NodeQuery.html" title="interface in org.testfx.service.query">NodeQuery</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#lookup(java.util.function.Function)">lookup</a></span>&#8203;(<a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/function/Function.html?is-external=true" title="class or interface in java.util.function" class="externalLink">Function</a>&lt;javafx.scene.Node,&#8203;<a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/Set.html?is-external=true" title="class or interface in java.util" class="externalLink">Set</a>&lt;javafx.scene.Node&gt;&gt;&nbsp;function)</code></th>
<td class="colLast">
<div class="block">Sifts through stored nodes and uses <code>function</code> to determine which nodes to keep and which to remove.</div>
</td>
</tr>
<tr class="altColor" id="i4">
<td class="colFirst"><code>&lt;T extends javafx.scene.Node&gt;<br><a href="NodeQuery.html" title="interface in org.testfx.service.query">NodeQuery</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#lookup(java.util.function.Predicate)">lookup</a></span>&#8203;(<a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/function/Predicate.html?is-external=true" title="class or interface in java.util.function" class="externalLink">Predicate</a>&lt;T&gt;&nbsp;predicate)</code></th>
<td class="colLast">
<div class="block">Sifts through stored nodes and keeps only those <code>Node</code>s that pass the given <code>predicate</code>.</div>
</td>
</tr>
<tr class="rowColor" id="i5">
<td class="colFirst"><code>&lt;T&gt;&nbsp;<a href="NodeQuery.html" title="interface in org.testfx.service.query">NodeQuery</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#lookup(org.hamcrest.Matcher)">lookup</a></span>&#8203;(org.hamcrest.Matcher&lt;T&gt;&nbsp;matcher)</code></th>
<td class="colLast">
<div class="block">Sifts through stored nodes and keeps only those <code>Node</code>s that match the given matcher.</div>
</td>
</tr>
<tr class="altColor" id="i6">
<td class="colFirst"><code>&lt;T extends javafx.scene.Node&gt;<br><a href="NodeQuery.html" title="interface in org.testfx.service.query">NodeQuery</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#match(java.util.function.Predicate)">match</a></span>&#8203;(<a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/function/Predicate.html?is-external=true" title="class or interface in java.util.function" class="externalLink">Predicate</a>&lt;T&gt;&nbsp;predicate)</code></th>
<td class="colLast">
<div class="block">Sifts through stored nodes and keeps only those <code>Node</code>s that pass the given predicate.</div>
</td>
</tr>
<tr class="rowColor" id="i7">
<td class="colFirst"><code>&lt;T&gt;&nbsp;<a href="NodeQuery.html" title="interface in org.testfx.service.query">NodeQuery</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#match(org.hamcrest.Matcher)">match</a></span>&#8203;(org.hamcrest.Matcher&lt;T&gt;&nbsp;matcher)</code></th>
<td class="colLast">
<div class="block">Sifts through stored nodes and keeps only those <code>Node</code>s that match the given matcher.</div>
</td>
</tr>
<tr class="altColor" id="i8">
<td class="colFirst"><code><a href="NodeQuery.html" title="interface in org.testfx.service.query">NodeQuery</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#nth(int)">nth</a></span>&#8203;(int&nbsp;index)</code></th>
<td class="colLast">
<div class="block">Keeps the nth <code>Node</code> in stored nodes and removes all others.</div>
</td>
</tr>
<tr class="rowColor" id="i9">
<td class="colFirst"><code>&lt;T extends javafx.scene.Node&gt;<br>T</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#query()">query</a></span>()</code></th>
<td class="colLast">
<div class="block">Executes this <code>NodeQuery</code> and returns the first <code>Node</code> found that matches
 this query.</div>
</td>
</tr>
<tr class="altColor" id="i10">
<td class="colFirst"><code>&lt;T extends javafx.scene.Node&gt;<br><a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/Set.html?is-external=true" title="class or interface in java.util" class="externalLink">Set</a>&lt;T&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#queryAll()">queryAll</a></span>()</code></th>
<td class="colLast">
<div class="block">Executes this <code>NodeQuery</code> and returns the <code>Set</code> of all the <code>Node</code>s that
 match this query.</div>
</td>
</tr>
<tr class="rowColor" id="i11">
<td class="colFirst"><code>&lt;T extends javafx.scene.Node&gt;<br><a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/Set.html?is-external=true" title="class or interface in java.util" class="externalLink">Set</a>&lt;T&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#queryAllAs(java.lang.Class)">queryAllAs</a></span>&#8203;(<a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Class.html?is-external=true" title="class or interface in java.lang" class="externalLink">Class</a>&lt;T&gt;&nbsp;clazz)</code></th>
<td class="colLast">
<div class="block">Type-safe version of <a href="#queryAll()"><code>queryAll()</code></a> that executes this <code>NodeQuery</code> and returns
 the <code>Set</code> of all the <code>Node</code>s that match this query.</div>
</td>
</tr>
<tr class="altColor" id="i12">
<td class="colFirst"><code>&lt;T extends javafx.scene.Node&gt;<br>T</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#queryAs(java.lang.Class)">queryAs</a></span>&#8203;(<a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Class.html?is-external=true" title="class or interface in java.lang" class="externalLink">Class</a>&lt;T&gt;&nbsp;clazz)</code></th>
<td class="colLast">
<div class="block">Type-safe version of <a href="#query()"><code>query()</code></a> that executes this <code>NodeQuery</code> and returns
 the first <code>Node</code> found that matches this query.</div>
</td>
</tr>
<tr class="rowColor" id="i13">
<td class="colFirst"><code>default javafx.scene.control.Button</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#queryButton()">queryButton</a></span>()</code></th>
<td class="colLast">
<div class="block">Executes this <code>NodeQuery</code> and returns the first <code>Button</code> found that matches
 this query.</div>
</td>
</tr>
<tr class="altColor" id="i14">
<td class="colFirst"><code>default &lt;T&gt;&nbsp;javafx.scene.control.ComboBox&lt;T&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#queryComboBox()">queryComboBox</a></span>()</code></th>
<td class="colLast">
<div class="block">Executes this <code>NodeQuery</code> and returns the first <code>ComboBox</code> found that matches
 this query.</div>
</td>
</tr>
<tr class="rowColor" id="i15">
<td class="colFirst"><code>default javafx.scene.control.Labeled</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#queryLabeled()">queryLabeled</a></span>()</code></th>
<td class="colLast">
<div class="block">Executes this <code>NodeQuery</code> and returns the first <code>Labeled</code> found that matches
 this query.</div>
</td>
</tr>
<tr class="altColor" id="i16">
<td class="colFirst"><code>default &lt;T&gt;&nbsp;javafx.scene.control.ListView&lt;T&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#queryListView()">queryListView</a></span>()</code></th>
<td class="colLast">
<div class="block">Executes this <code>NodeQuery</code> and returns the first <code>ListView</code> found that matches
 this query.</div>
</td>
</tr>
<tr class="rowColor" id="i17">
<td class="colFirst"><code>default javafx.scene.Parent</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#queryParent()">queryParent</a></span>()</code></th>
<td class="colLast">
<div class="block">Executes this <code>NodeQuery</code> and returns the first <code>Parent</code> found that matches
 this query.</div>
</td>
</tr>
<tr class="altColor" id="i18">
<td class="colFirst"><code>default &lt;T&gt;&nbsp;javafx.scene.control.TableView&lt;T&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#queryTableView()">queryTableView</a></span>()</code></th>
<td class="colLast">
<div class="block">Executes this <code>NodeQuery</code> and returns the first <code>TableView</code> found that matches
 this query.</div>
</td>
</tr>
<tr class="rowColor" id="i19">
<td class="colFirst"><code>default javafx.scene.text.Text</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#queryText()">queryText</a></span>()</code></th>
<td class="colLast">
<div class="block">Executes this <code>NodeQuery</code> and returns the first <code>Text</code> found that matches
 this query.</div>
</td>
</tr>
<tr class="altColor" id="i20">
<td class="colFirst"><code>default javafx.scene.text.TextFlow</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#queryTextFlow()">queryTextFlow</a></span>()</code></th>
<td class="colLast">
<div class="block">Executes this <code>NodeQuery</code> and returns the first <code>TextFlow</code> found that matches
 this query.</div>
</td>
</tr>
<tr class="rowColor" id="i21">
<td class="colFirst"><code>default javafx.scene.control.TextInputControl</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#queryTextInputControl()">queryTextInputControl</a></span>()</code></th>
<td class="colLast">
<div class="block">Executes this <code>NodeQuery</code> and returns the first <code>TextInputControl</code> found that matches
 this query.</div>
</td>
</tr>
<tr class="altColor" id="i22">
<td class="colFirst"><code>&lt;T extends javafx.scene.Node&gt;<br><a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/Optional.html?is-external=true" title="class or interface in java.util" class="externalLink">Optional</a>&lt;T&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#tryQuery()">tryQuery</a></span>()</code></th>
<td class="colLast">
<div class="block">Executes this <code>NodeQuery</code> and returns an <code>Optional</code> that either contains
 the first <code>Node</code> found that matches this query or nothing (e.g.</div>
</td>
</tr>
<tr class="rowColor" id="i23">
<td class="colFirst"><code>&lt;T extends javafx.scene.Node&gt;<br><a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/Optional.html?is-external=true" title="class or interface in java.util" class="externalLink">Optional</a>&lt;T&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#tryQueryAs(java.lang.Class)">tryQueryAs</a></span>&#8203;(<a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Class.html?is-external=true" title="class or interface in java.lang" class="externalLink">Class</a>&lt;T&gt;&nbsp;clazz)</code></th>
<td class="colLast">
<div class="block">Type-safe version of <a href="#tryQuery()"><code>tryQuery()</code></a> that executes this <code>NodeQuery</code> and returns an
 <code>Optional</code> that either contains the first <code>Node</code> found that matches this query or
 nothing (e.g.</div>
</td>
</tr>
</tbody>
</table>
</div>
</div>
</li>
</ul>
</section>
</li>
</ul>
</div>
<div class="details">
<ul class="blockList">
<li class="blockList">
<!-- ============ METHOD DETAIL ========== -->
<section role="region">
<ul class="blockList">
<li class="blockList"><a id="method.detail">
<!--   -->
</a>
<h3>Method Detail</h3>
<a id="from(javafx.scene.Node...)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>from</h4>
<pre class="methodSignature"><a href="NodeQuery.html" title="interface in org.testfx.service.query">NodeQuery</a>&nbsp;from&#8203;(javafx.scene.Node...&nbsp;parentNodes)</pre>
<div class="block">Stores all given <code>parentNodes</code> within this NodeQuery.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>parentNodes</code> - the parentNodes to store</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>itself for more method chaining</dd>
</dl>
</li>
</ul>
<a id="from(java.util.Collection)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>from</h4>
<pre class="methodSignature"><a href="NodeQuery.html" title="interface in org.testfx.service.query">NodeQuery</a>&nbsp;from&#8203;(<a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/Collection.html?is-external=true" title="class or interface in java.util" class="externalLink">Collection</a>&lt;javafx.scene.Node&gt;&nbsp;parentNodes)</pre>
<div class="block">Stores all given <code>parentNodes</code> within this NodeQuery.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>parentNodes</code> - the parentNodes to store</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>itself for more method chaining</dd>
</dl>
</li>
</ul>
<a id="lookup(java.lang.String)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>lookup</h4>
<pre class="methodSignature"><a href="NodeQuery.html" title="interface in org.testfx.service.query">NodeQuery</a>&nbsp;lookup&#8203;(<a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/String.html?is-external=true" title="class or interface in java.lang" class="externalLink">String</a>&nbsp;query)</pre>
<div class="block">Sifts through stored nodes by their id ("#id"), their class (".class"), or the text it has ("text"),
 depending on the query used, and keeps only those <code>Node</code>s that meet the query.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>query</code> - the query to use</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>itself for more method chaining</dd>
</dl>
</li>
</ul>
<a id="lookup(org.hamcrest.Matcher)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>lookup</h4>
<pre class="methodSignature">&lt;T&gt;&nbsp;<a href="NodeQuery.html" title="interface in org.testfx.service.query">NodeQuery</a>&nbsp;lookup&#8203;(org.hamcrest.Matcher&lt;T&gt;&nbsp;matcher)</pre>
<div class="block">Sifts through stored nodes and keeps only those <code>Node</code>s that match the given matcher.</div>
<dl>
<dt><span class="paramLabel">Type Parameters:</span></dt>
<dd><code>T</code> - matcher type</dd>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>matcher</code> - the matcher used to determine which <code>Node</code>s to keep and which to remove</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>itself for more method chaining</dd>
</dl>
</li>
</ul>
<a id="lookup(java.util.function.Predicate)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>lookup</h4>
<pre class="methodSignature">&lt;T extends javafx.scene.Node&gt;&nbsp;<a href="NodeQuery.html" title="interface in org.testfx.service.query">NodeQuery</a>&nbsp;lookup&#8203;(<a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/function/Predicate.html?is-external=true" title="class or interface in java.util.function" class="externalLink">Predicate</a>&lt;T&gt;&nbsp;predicate)</pre>
<div class="block">Sifts through stored nodes and keeps only those <code>Node</code>s that pass the given <code>predicate</code>.</div>
<dl>
<dt><span class="paramLabel">Type Parameters:</span></dt>
<dd><code>T</code> - type that extends <code>Node</code></dd>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>predicate</code> - the predicate used to determine which <code>Node</code>s to keep and which to remove.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>itself for more method chaining</dd>
</dl>
</li>
</ul>
<a id="lookup(java.util.function.Function)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>lookup</h4>
<pre class="methodSignature"><a href="NodeQuery.html" title="interface in org.testfx.service.query">NodeQuery</a>&nbsp;lookup&#8203;(<a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/function/Function.html?is-external=true" title="class or interface in java.util.function" class="externalLink">Function</a>&lt;javafx.scene.Node,&#8203;<a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/Set.html?is-external=true" title="class or interface in java.util" class="externalLink">Set</a>&lt;javafx.scene.Node&gt;&gt;&nbsp;function)</pre>
<div class="block">Sifts through stored nodes and uses <code>function</code> to determine which nodes to keep and which to remove.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>function</code> - that returns the <code>Node</code>s to keep</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>itself for more method chaining</dd>
</dl>
</li>
</ul>
<a id="match(org.hamcrest.Matcher)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>match</h4>
<pre class="methodSignature">&lt;T&gt;&nbsp;<a href="NodeQuery.html" title="interface in org.testfx.service.query">NodeQuery</a>&nbsp;match&#8203;(org.hamcrest.Matcher&lt;T&gt;&nbsp;matcher)</pre>
<div class="block">Sifts through stored nodes and keeps only those <code>Node</code>s that match the given matcher.</div>
<dl>
<dt><span class="paramLabel">Type Parameters:</span></dt>
<dd><code>T</code> - matcher type</dd>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>matcher</code> - that determines which <code>Node</code>s to keep</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>itself for more method chaining</dd>
</dl>
</li>
</ul>
<a id="match(java.util.function.Predicate)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>match</h4>
<pre class="methodSignature">&lt;T extends javafx.scene.Node&gt;&nbsp;<a href="NodeQuery.html" title="interface in org.testfx.service.query">NodeQuery</a>&nbsp;match&#8203;(<a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/function/Predicate.html?is-external=true" title="class or interface in java.util.function" class="externalLink">Predicate</a>&lt;T&gt;&nbsp;predicate)</pre>
<div class="block">Sifts through stored nodes and keeps only those <code>Node</code>s that pass the given predicate.</div>
<dl>
<dt><span class="paramLabel">Type Parameters:</span></dt>
<dd><code>T</code> - predicate type</dd>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>predicate</code> - that indicates which <code>Node</code>s to keep</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>itself for more method chaining</dd>
</dl>
</li>
</ul>
<a id="nth(int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>nth</h4>
<pre class="methodSignature"><a href="NodeQuery.html" title="interface in org.testfx.service.query">NodeQuery</a>&nbsp;nth&#8203;(int&nbsp;index)</pre>
<div class="block">Keeps the nth <code>Node</code> in stored nodes and removes all others.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>index</code> - within the collection of <code>Node</code>s</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>itself for more method chaining</dd>
</dl>
</li>
</ul>
<a id="query()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>query</h4>
<pre class="methodSignature">&lt;T extends javafx.scene.Node&gt;&nbsp;T&nbsp;query()</pre>
<div class="block">Executes this <code>NodeQuery</code> and returns the first <code>Node</code> found that matches
 this query. If no nodes match this query then an <a href="EmptyNodeQueryException.html" title="class in org.testfx.service.query"><code>EmptyNodeQueryException</code></a> is thrown.
 <p>
 The determinism of this method relies on the determinism of <code>Node.lookupAll(String)</code>,
 for which the JavaDocs specifically state that the result is unordered. The current (9.0.4)
 version of JavaFX happens to return the nodes in the order in which they are encountered whilst
 traversing the scene graph but this could change in future versions of JavaFX. Thus if there are
 multiple nodes matched by this query and you want a specific one it is advised not to use this
 method and instead narrow the query so that only one node is matched.</div>
<dl>
<dt><span class="paramLabel">Type Parameters:</span></dt>
<dd><code>T</code> - the type that extends <code>Node</code></dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>the first node found that matches this query, if any</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code><a href="EmptyNodeQueryException.html" title="class in org.testfx.service.query">EmptyNodeQueryException</a></code> - if no <code>TextFlow</code> nodes match this query</dd>
</dl>
</li>
</ul>
<a id="queryButton()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>queryButton</h4>
<pre class="methodSignature">default&nbsp;javafx.scene.control.Button&nbsp;queryButton()</pre>
<div class="block">Executes this <code>NodeQuery</code> and returns the first <code>Button</code> found that matches
 this query. If no nodes match this query then an <a href="EmptyNodeQueryException.html" title="class in org.testfx.service.query"><code>EmptyNodeQueryException</code></a> is thrown.
 <p>
 The determinism of this method relies on the determinism of <code>Node.lookupAll(String)</code>,
 for which the JavaDocs specifically state that the result is unordered. The current (9.0.4)
 version of JavaFX happens to return the nodes in the order in which they are encountered whilst
 traversing the scene graph but this could change in future versions of JavaFX. Thus if there are
 multiple nodes matched by this query and you want a specific one it is advised not to use this
 method and instead narrow the query so that only one node is matched.</div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>the first <code>Button</code> found that matches this query, if any</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code><a href="EmptyNodeQueryException.html" title="class in org.testfx.service.query">EmptyNodeQueryException</a></code> - if no <code>Button</code> nodes match this query</dd>
</dl>
</li>
</ul>
<a id="queryComboBox()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>queryComboBox</h4>
<pre class="methodSignature">default&nbsp;&lt;T&gt;&nbsp;javafx.scene.control.ComboBox&lt;T&gt;&nbsp;queryComboBox()</pre>
<div class="block">Executes this <code>NodeQuery</code> and returns the first <code>ComboBox</code> found that matches
 this query. If no nodes match this query then an <a href="EmptyNodeQueryException.html" title="class in org.testfx.service.query"><code>EmptyNodeQueryException</code></a> is thrown.
 <p>
 The determinism of this method relies on the determinism of <code>Node.lookupAll(String)</code>,
 for which the JavaDocs specifically state that the result is unordered. The current (9.0.4)
 version of JavaFX happens to return the nodes in the order in which they are encountered whilst
 traversing the scene graph but this could change in future versions of JavaFX. Thus if there are
 multiple nodes matched by this query and you want a specific one it is advised not to use this
 method and instead narrow the query so that only one node is matched.</div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>the first <code>ComboBox</code> found that matches this query, if any</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code><a href="EmptyNodeQueryException.html" title="class in org.testfx.service.query">EmptyNodeQueryException</a></code> - if no <code>ComboBox</code> nodes match this query</dd>
</dl>
</li>
</ul>
<a id="queryLabeled()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>queryLabeled</h4>
<pre class="methodSignature">default&nbsp;javafx.scene.control.Labeled&nbsp;queryLabeled()</pre>
<div class="block">Executes this <code>NodeQuery</code> and returns the first <code>Labeled</code> found that matches
 this query. If no nodes match this query then an <a href="EmptyNodeQueryException.html" title="class in org.testfx.service.query"><code>EmptyNodeQueryException</code></a> is thrown.
 <p>
 The determinism of this method relies on the determinism of <code>Node.lookupAll(String)</code>,
 for which the JavaDocs specifically state that the result is unordered. The current (9.0.4)
 version of JavaFX happens to return the nodes in the order in which they are encountered whilst
 traversing the scene graph but this could change in future versions of JavaFX. Thus if there are
 multiple nodes matched by this query and you want a specific one it is advised not to use this
 method and instead narrow the query so that only one node is matched.</div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>the first <code>Labeled</code> found that matches this query, if any</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code><a href="EmptyNodeQueryException.html" title="class in org.testfx.service.query">EmptyNodeQueryException</a></code> - if no <code>Labeled</code> nodes match this query</dd>
</dl>
</li>
</ul>
<a id="queryListView()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>queryListView</h4>
<pre class="methodSignature">default&nbsp;&lt;T&gt;&nbsp;javafx.scene.control.ListView&lt;T&gt;&nbsp;queryListView()</pre>
<div class="block">Executes this <code>NodeQuery</code> and returns the first <code>ListView</code> found that matches
 this query. If no nodes match this query then an <a href="EmptyNodeQueryException.html" title="class in org.testfx.service.query"><code>EmptyNodeQueryException</code></a> is thrown.
 <p>
 The determinism of this method relies on the determinism of <code>Node.lookupAll(String)</code>,
 for which the JavaDocs specifically state that the result is unordered. The current (9.0.4)
 version of JavaFX happens to return the nodes in the order in which they are encountered whilst
 traversing the scene graph but this could change in future versions of JavaFX. Thus if there are
 multiple nodes matched by this query and you want a specific one it is advised not to use this
 method and instead narrow the query so that only one node is matched.</div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>the first <code>ListView</code> found that matches this query, if any</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code><a href="EmptyNodeQueryException.html" title="class in org.testfx.service.query">EmptyNodeQueryException</a></code> - if no <code>ListView</code> nodes match this query</dd>
</dl>
</li>
</ul>
<a id="queryParent()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>queryParent</h4>
<pre class="methodSignature">default&nbsp;javafx.scene.Parent&nbsp;queryParent()</pre>
<div class="block">Executes this <code>NodeQuery</code> and returns the first <code>Parent</code> found that matches
 this query. If no nodes match this query then an <a href="EmptyNodeQueryException.html" title="class in org.testfx.service.query"><code>EmptyNodeQueryException</code></a> is thrown.
 <p>
 The determinism of this method relies on the determinism of <code>Node.lookupAll(String)</code>,
 for which the JavaDocs specifically state that the result is unordered. The current (9.0.4)
 version of JavaFX happens to return the nodes in the order in which they are encountered whilst
 traversing the scene graph but this could change in future versions of JavaFX. Thus if there are
 multiple nodes matched by this query and you want a specific one it is advised not to use this
 method and instead narrow the query so that only one node is matched.</div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>the first <code>Parent</code> found that matches this query, if any</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code><a href="EmptyNodeQueryException.html" title="class in org.testfx.service.query">EmptyNodeQueryException</a></code> - if no <code>Parent</code> nodes match this query</dd>
</dl>
</li>
</ul>
<a id="queryTableView()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>queryTableView</h4>
<pre class="methodSignature">default&nbsp;&lt;T&gt;&nbsp;javafx.scene.control.TableView&lt;T&gt;&nbsp;queryTableView()</pre>
<div class="block">Executes this <code>NodeQuery</code> and returns the first <code>TableView</code> found that matches
 this query. If no nodes match this query then an <a href="EmptyNodeQueryException.html" title="class in org.testfx.service.query"><code>EmptyNodeQueryException</code></a> is thrown.
 <p>
 The determinism of this method relies on the determinism of <code>Node.lookupAll(String)</code>,
 for which the JavaDocs specifically state that the result is unordered. The current (9.0.4)
 version of JavaFX happens to return the nodes in the order in which they are encountered whilst
 traversing the scene graph but this could change in future versions of JavaFX. Thus if there are
 multiple nodes matched by this query and you want a specific one it is advised not to use this
 method and instead narrow the query so that only one node is matched.</div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>the first <code>TableView</code> found that matches this query, if any</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code><a href="EmptyNodeQueryException.html" title="class in org.testfx.service.query">EmptyNodeQueryException</a></code> - if no <code>TableView</code> nodes match this query</dd>
</dl>
</li>
</ul>
<a id="queryText()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>queryText</h4>
<pre class="methodSignature">default&nbsp;javafx.scene.text.Text&nbsp;queryText()</pre>
<div class="block">Executes this <code>NodeQuery</code> and returns the first <code>Text</code> found that matches
 this query. If no nodes match this query then an <a href="EmptyNodeQueryException.html" title="class in org.testfx.service.query"><code>EmptyNodeQueryException</code></a> is thrown.
 <p>
 The determinism of this method relies on the determinism of <code>Node.lookupAll(String)</code>,
 for which the JavaDocs specifically state that the result is unordered. The current (9.0.4)
 version of JavaFX happens to return the nodes in the order in which they are encountered whilst
 traversing the scene graph but this could change in future versions of JavaFX. Thus if there are
 multiple nodes matched by this query and you want a specific one it is advised not to use this
 method and instead narrow the query so that only one node is matched.</div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>the first <code>Text</code> found that matches this query, if any</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code><a href="EmptyNodeQueryException.html" title="class in org.testfx.service.query">EmptyNodeQueryException</a></code> - if no <code>Text</code> nodes match this query</dd>
</dl>
</li>
</ul>
<a id="queryTextFlow()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>queryTextFlow</h4>
<pre class="methodSignature">default&nbsp;javafx.scene.text.TextFlow&nbsp;queryTextFlow()</pre>
<div class="block">Executes this <code>NodeQuery</code> and returns the first <code>TextFlow</code> found that matches
 this query. If no nodes match this query then an <a href="EmptyNodeQueryException.html" title="class in org.testfx.service.query"><code>EmptyNodeQueryException</code></a> is thrown.
 <p>
 The determinism of this method relies on the determinism of <code>Node.lookupAll(String)</code>,
 for which the JavaDocs specifically state that the result is unordered. The current (9.0.4)
 version of JavaFX happens to return the nodes in the order in which they are encountered whilst
 traversing the scene graph but this could change in future versions of JavaFX. Thus if there are
 multiple nodes matched by this query and you want a specific one it is advised not to use this
 method and instead narrow the query so that only one node is matched.</div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>the first <code>TextFlow</code> found that matches this query, if any</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code><a href="EmptyNodeQueryException.html" title="class in org.testfx.service.query">EmptyNodeQueryException</a></code> - if no <code>TextFlow</code> nodes match this query</dd>
</dl>
</li>
</ul>
<a id="queryTextInputControl()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>queryTextInputControl</h4>
<pre class="methodSignature">default&nbsp;javafx.scene.control.TextInputControl&nbsp;queryTextInputControl()</pre>
<div class="block">Executes this <code>NodeQuery</code> and returns the first <code>TextInputControl</code> found that matches
 this query. If no nodes match this query then an <a href="EmptyNodeQueryException.html" title="class in org.testfx.service.query"><code>EmptyNodeQueryException</code></a> is thrown.
 <p>
 The determinism of this method relies on the determinism of <code>Node.lookupAll(String)</code>,
 for which the JavaDocs specifically state that the result is unordered. The current (9.0.4)
 version of JavaFX happens to return the nodes in the order in which they are encountered whilst
 traversing the scene graph but this could change in future versions of JavaFX. Thus if there are
 multiple nodes matched by this query and you want a specific one it is advised not to use this
 method and instead narrow the query so that only one node is matched.</div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>the first <code>TextInputControl</code> found that matches this query, if any</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code><a href="EmptyNodeQueryException.html" title="class in org.testfx.service.query">EmptyNodeQueryException</a></code> - if no <code>TextInputControl</code> nodes match this query</dd>
</dl>
</li>
</ul>
<a id="queryAs(java.lang.Class)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>queryAs</h4>
<pre class="methodSignature">&lt;T extends javafx.scene.Node&gt;&nbsp;T&nbsp;queryAs&#8203;(<a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Class.html?is-external=true" title="class or interface in java.lang" class="externalLink">Class</a>&lt;T&gt;&nbsp;clazz)</pre>
<div class="block">Type-safe version of <a href="#query()"><code>query()</code></a> that executes this <code>NodeQuery</code> and returns
 the first <code>Node</code> found that matches this query. If no nodes match this query then
 an <a href="EmptyNodeQueryException.html" title="class in org.testfx.service.query"><code>EmptyNodeQueryException</code></a> is thrown.
 <p>
 The determinism of this method relies on the determinism of <code>Node.lookupAll(String)</code>,
 for which the JavaDocs specifically state that the result is unordered. The current (9.0.4)
 version of JavaFX happens to return the nodes in the order in which they are encountered whilst
 traversing the scene graph but this could change in future versions of JavaFX. Thus if there are
 multiple nodes matched by this query and you want a specific one it is advised not to use this
 method and instead narrow the query so that only one node is matched.</div>
<dl>
<dt><span class="paramLabel">Type Parameters:</span></dt>
<dd><code>T</code> - the type that extends <code>Node</code></dd>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>clazz</code> - the concrete sub-type of <code>Node</code> that should be returned by this query
 so as to avoid extraneous casting when used inside an "assertThat" assertion</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>the first node found that matches this query, if any</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code><a href="EmptyNodeQueryException.html" title="class in org.testfx.service.query">EmptyNodeQueryException</a></code> - if no nodes match this query</dd>
</dl>
</li>
</ul>
<a id="tryQuery()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>tryQuery</h4>
<pre class="methodSignature">&lt;T extends javafx.scene.Node&gt;&nbsp;<a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/Optional.html?is-external=true" title="class or interface in java.util" class="externalLink">Optional</a>&lt;T&gt;&nbsp;tryQuery()</pre>
<div class="block">Executes this <code>NodeQuery</code> and returns an <code>Optional</code> that either contains
 the first <code>Node</code> found that matches this query or nothing (e.g. <a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/Optional.html?is-external=true#empty()" title="class or interface in java.util" class="externalLink"><code>Optional.empty()</code></a>
 returns true) if no nodes match this query.
 <p>
 The determinism of this method relies on the determinism of <code>Node.lookupAll(String)</code>,
 for which the JavaDocs specifically state that the result is unordered. The current (9.0.4)
 version of JavaFX happens to return the nodes in the order in which they are encountered whilst
 traversing the scene graph but this could change in future versions of JavaFX. Thus if there are
 multiple nodes matched by this query and you want a specific one it is advised not to use this
 method and instead narrow the query so that only one node is matched.</div>
<dl>
<dt><span class="paramLabel">Type Parameters:</span></dt>
<dd><code>T</code> - the type that extends <code>Node</code></dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>the first node found or an empty <code>Optional</code> if the query does not match any nodes</dd>
</dl>
</li>
</ul>
<a id="tryQueryAs(java.lang.Class)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>tryQueryAs</h4>
<pre class="methodSignature">&lt;T extends javafx.scene.Node&gt;&nbsp;<a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/Optional.html?is-external=true" title="class or interface in java.util" class="externalLink">Optional</a>&lt;T&gt;&nbsp;tryQueryAs&#8203;(<a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Class.html?is-external=true" title="class or interface in java.lang" class="externalLink">Class</a>&lt;T&gt;&nbsp;clazz)</pre>
<div class="block">Type-safe version of <a href="#tryQuery()"><code>tryQuery()</code></a> that executes this <code>NodeQuery</code> and returns an
 <code>Optional</code> that either contains the first <code>Node</code> found that matches this query or
 nothing (e.g. <a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/Optional.html?is-external=true#empty()" title="class or interface in java.util" class="externalLink"><code>Optional.empty()</code></a> returns true) if no nodes match this query.
 <p>
 The determinism of this method relies on the determinism of <code>Node.lookupAll(String)</code>,
 for which the JavaDocs specifically state that the result is unordered. The current (9.0.4)
 version of JavaFX happens to return the nodes in the order in which they are encountered whilst
 traversing the scene graph but this could change in future versions of JavaFX. Thus if there are
 multiple nodes matched by this query and you want a specific one it is advised not to use this
 method and instead narrow the query so that only one node is matched.</div>
<dl>
<dt><span class="paramLabel">Type Parameters:</span></dt>
<dd><code>T</code> - the type that extends <code>Node</code></dd>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>clazz</code> - the concrete sub-type of <code>Node</code> that should be contained in the
 <code>Optional</code> returned by this query so as to avoid extraneous casting when used inside
 an "assertThat" assertion</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>the first node found or an empty <code>Optional</code> if the query does not match any nodes</dd>
</dl>
</li>
</ul>
<a id="queryAll()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>queryAll</h4>
<pre class="methodSignature">&lt;T extends javafx.scene.Node&gt;&nbsp;<a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/Set.html?is-external=true" title="class or interface in java.util" class="externalLink">Set</a>&lt;T&gt;&nbsp;queryAll()</pre>
<div class="block">Executes this <code>NodeQuery</code> and returns the <code>Set</code> of all the <code>Node</code>s that
 match this query. If no nodes match this query, the empty set is returned.</div>
<dl>
<dt><span class="paramLabel">Type Parameters:</span></dt>
<dd><code>T</code> - the type that extends <code>Node</code></dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>the set of nodes that match this query</dd>
</dl>
</li>
</ul>
<a id="queryAllAs(java.lang.Class)">
<!--   -->
</a>
<ul class="blockListLast">
<li class="blockList">
<h4>queryAllAs</h4>
<pre class="methodSignature">&lt;T extends javafx.scene.Node&gt;&nbsp;<a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/Set.html?is-external=true" title="class or interface in java.util" class="externalLink">Set</a>&lt;T&gt;&nbsp;queryAllAs&#8203;(<a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Class.html?is-external=true" title="class or interface in java.lang" class="externalLink">Class</a>&lt;T&gt;&nbsp;clazz)</pre>
<div class="block">Type-safe version of <a href="#queryAll()"><code>queryAll()</code></a> that executes this <code>NodeQuery</code> and returns
 the <code>Set</code> of all the <code>Node</code>s that match this query. If no nodes match this query,
 the empty set is returned.</div>
<dl>
<dt><span class="paramLabel">Type Parameters:</span></dt>
<dd><code>T</code> - the type that extends <code>Node</code></dd>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>clazz</code> - the concrete sub-type of <code>Node</code> the set of which should be returned by
 this query so as to avoid extraneous casting when used inside an "assertThat" assertion</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>the set of nodes that match this query</dd>
</dl>
</li>
</ul>
</li>
</ul>
</section>
</li>
</ul>
</div>
</div>
</main>
<!-- ========= END OF CLASS DATA ========= -->
<footer role="contentinfo">
<nav role="navigation">
<!-- ======= START OF BOTTOM NAVBAR ====== -->
<div class="bottomNav"><a id="navbar.bottom">
<!--   -->
</a>
<div class="skipNav"><a href="#skip.navbar.bottom" title="Skip navigation links">Skip navigation links</a></div>
<a id="navbar.bottom.firstrow">
<!--   -->
</a>
<ul class="navList" title="Navigation">
<li><a href="../../../../module-summary.html">Module</a></li>
<li><a href="package-summary.html">Package</a></li>
<li class="navBarCell1Rev">Class</li>
<li><a href="class-use/NodeQuery.html">Use</a></li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../../../../../deprecated-list.html">Deprecated</a></li>
<li><a href="../../../../../index-files/index-1.html">Index</a></li>
<li><a href="../../../../../help-doc.html">Help</a></li>
</ul>
<div class="aboutLanguage">Copyright &copy; 2013-2019 The TestFX Contributors. All rights reserved.</div>
</div>
<div class="subNav">
<div>
<ul class="subNavList">
<li>Summary:&nbsp;</li>
<li>Nested&nbsp;|&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li>Constr&nbsp;|&nbsp;</li>
<li><a href="#method.summary">Method</a></li>
</ul>
<ul class="subNavList">
<li>Detail:&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li>Constr&nbsp;|&nbsp;</li>
<li><a href="#method.detail">Method</a></li>
</ul>
</div>
</div>
<a id="skip.navbar.bottom">
<!--   -->
</a>
<!-- ======== END OF BOTTOM NAVBAR ======= -->
</nav>
</footer>
</body>
</html>
